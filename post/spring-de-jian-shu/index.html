<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring的简述 | Gridea</title>
<link rel="shortcut icon" href="https://hanmingwu.github.io/favicon.ico?v=1597667274694">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://hanmingwu.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Spring的简述 | Gridea - Atom Feed" href="https://hanmingwu.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="

历史:

interface21
Rod Jonnson
2004年
为了解决企业级应用开发的复杂度



优点

免费开源框架
轻量级的非侵入的框架
特点是控制反转(IOC)+面向切面编程(AOP)
支持对事务的处理,对框架整合支持
..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://hanmingwu.github.io">
  <img class="avatar" src="https://hanmingwu.github.io/images/avatar.png?v=1597667274694" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring的简述
            </h2>
            <div class="post-info">
              <span>
                2020-02-07
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <ol>
<li>
<p>历史:</p>
<ul>
<li>interface21</li>
<li>Rod Jonnson</li>
<li>2004年</li>
<li>为了解决企业级应用开发的复杂度</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>免费开源框架</li>
<li>轻量级的非侵入的框架</li>
<li>特点是控制反转(IOC)+面向切面编程(AOP)</li>
<li>支持对事务的处理,对框架整合支持</li>
<li>总结:Spring是一种轻量级的控制反转(IOC)和面向切面编程(AOP)的框架</li>
</ul>
</li>
<li>
<p>组成</p>
<ul>
<li>
<p>核心模块</p>
</li>
<li>
<p>七大组成部分</p>
</li>
</ul>
<blockquote>
<p>作用：</p>
</blockquote>
<ol>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ol>
<ul>
<li>SSM=springMVC+Spring+Mybatis</li>
<li>先学SpringMVC和Spring</li>
<li>拓展
<ol>
<li>Springboot
<ul>
<li>一个快速的脚手架</li>
<li>基于Springboot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Springcloud
<ul>
<li>Springcloud是基于Springboot实现的</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>学习Springboot的前提是要完全掌握Spring和SpringMVC</p>
</blockquote>
</li>
</ol>
<h2 id="ioc基础"><strong>IoC基础</strong></h2>
<p>新建一个空白的maven项目</p>
<blockquote>
<p>分析实现</p>
</blockquote>
<p>我们先用我们原来的方式写一段代码 .</p>
<p>1、先写一个UserDao接口</p>
<pre><code class="language-java">public interface UserDao {
   public void getUser();
}
</code></pre>
<p>2、再去写Dao的实现类</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;获取用户数据&quot;);
  }
}
</code></pre>
<p>3、然后去写UserService的接口</p>
<pre><code class="language-java">public interface UserService {
   public void getUser();
}
</code></pre>
<p>4、最后写Service的实现类</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>5、测试一下</p>
<pre><code class="language-java">@Test
public void test(){
   UserService service = new UserServiceImpl();
   service.getUser();
}
</code></pre>
<p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p>
<p>把Userdao的实现类增加一个 .</p>
<pre><code class="language-java">public class UserDaoMySqlImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;MySql获取用户数据&quot;);
  }
}
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoMySqlImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>在假设, 我们再增加一个Userdao的实现类 .</p>
<pre><code class="language-java">public class UserDaoOracleImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;Oracle获取用户数据&quot;);
  }
}
</code></pre>
<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p>
<p><strong>那我们如何去解决呢 ?</strong></p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
   private UserDao userDao;
// 利用set实现
   public void setUserDao(UserDao userDao) {
       this.userDao = userDao;
  }

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>现在去我们的测试类里 , 进行测试 ;</p>
<pre><code class="language-java">@Test
public void test(){
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
}
</code></pre>
<p>大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p>
<p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<blockquote>
<p>IOC本质</p>
</blockquote>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#ioc%E5%9F%BA%E7%A1%80"><strong>IoC基础</strong></a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://hanmingwu.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
